
# The GNU Linker

> 本文档由 [MurphyZhao](https://github.com/murphyzhao/) 与 2019 年 8 月 23 日翻译。  
> 文档来源于 **gcc-arm-none-eabi-4_8-2014q3-20140805-linux.tar.bz2** 中的 `share/doc/gcc-arm-none-eabi/html/ld.html`。

```
            ld
(GNU Binutils)
Version 2.23.2
```

此文件基于 GNU 链接器 ld（GNU Binutils）版本 2.23.2。

本文档根据 GNU 自由文档许可证 1.3 版的条款分发。许可证的副本包含在标题为 “GNU 自由文档许可证” 的部分中。

# 1 概览

ld 软件组合一系列的 object 和 archive（目标/归档） 文件，重定位他们的数据并绑定符号引用（symbol references）。通常在程序编译的最后一步执行 ld 软件进行程序链接。

ld 软件接受以 AT＆T 的 **链接编辑器命令语言** 语法的超集编写的链接器命令语言文件，以提供对链接过程的显式和完全控制。

这个版本，LD 使用通用 BFD 库来操作目标文件。这允许 LD 以多种不同的格式读取、组合和写入目标文件 -  例如，COFF 或 a.out。可以将不同的格式链接在一起以产生任何可用类型的目标文件（object file）。有关更多信息，请参阅 BFD。

除了灵活性之外，gnu 链接器在提供诊断信息方面比其他链接器更有帮助。许多链接器在遇到错误时立即放弃执行; 只要有可能，LD  继续执行，允许您识别其他错误（或者，在某些情况下，尽管出现错误，仍然可以获取输出文件）。

# 2 调用 / 祈祷（Invocation）

GNU 链接器 ld 旨在涵盖广泛的情况，并尽可能与其他链接器兼容。因此，您有很多选择来控制其行为。

- Optios：命令行选项
- Environment：环境变量

## 2.1 命令行选项

链接器支持大量的命令行选项，但在实际操作中，只有他们中很少的一部分被用于特定的上下文。 例如，LD 经常被用于在标准的、受支持的 Unix 系统上链接标准的 Unix 目标文件。在这样的系统上，去链接文件 hello.o 如下所示：

```
    ld -o output /lib/crt0.o hello.o -lc
```

上述代码表示 LD 使用 `/lib/crt0.o` 和 `hello.o` 以及 `libc.a` 生成一个名为 *output* 的输出文件，这些输入文件来自标准搜索目录。（参考下面关于 `-l` 选项的讨论）



# 3 链接脚本

每一次链接（link）都是由链接*脚本脚本*。此脚本使用链接器命令语言编写。

链接脚本的主要目的是描述输入文件中的各部分（sections）应如何映射到输出文件，以及控制输出文件的内存布局。大多数链接器脚本仅会执行这些操作。但是，必要时，链接脚本还可以使用下面描述的命令指示链接器执行更多其他操作。

链接器始终使用链接脚本。如果您自己不提供，则链接器将使用编译到链接器可执行文件中的默认脚本。你可以使用 `--verbose` 命令行选项显示默认链接脚本。某些命令行选项，例如 `-r` 要么 `-N`，会影响默认的链接描述文件。

您可以使用 `-T` 命令行选项指定自己的链接描述文件。执行此操作时，链接描述文件将替换默认链接描述文件。

您也可以隐式使用链接描述文件，将它们命名为链接器的输入文件，就好像它们是要链接的文件一样。请参阅[隐式链接描述文件]()。

- Basic Script Concepts: 基本的链接脚本概念
- Script Format: 链接脚本格式
- Simple Example: 简单的链接脚本示例
- Simple Commands: 简单的链接脚本命令
- Assignments: 分配，将值分配给符号
- SECTIONS: SECTIONS 命令
- MEMORY: MEMORY 命令
- PHDRS: PHDRS 命令
- VERSION: VERSION 命令
- Expressions: 链接脚本中的表达式
- Implicit Linker Scripts: 隐式链接描述文件

## 3.1 基本的链接脚本概念

我们需要定义一些基本概念和词汇表来描述链接器脚本语言。

链接器将输入文件合并为单个输出文件。输出文件和每个输入文件采用称为 *目标文件格式* 的特殊数据 格式。每个文件都称为 *目标文件*（object file）。输出文件通常称为 *可执行文件*，但出于我们的目的，我们也将其称为目标文件。除了别的以外，每个目标文件都有一个 `*sections*` 列表。我们有时将输入文件中的一个 section 称为 *输入 section*；类似地，输出文件中的 section 是 *输出 section*。

目标文件中的每个 section 都有名称和大小。大多数 section 还有一个相关的数据块，称为 *section 内容*。一个 section 可能被标记为 *可加载*，这意味着在运行输出文件时，应将 section 内容加载到内存中。没有内容的 section 可以是 *可分配的*，这意味着应该在内存中留出一片区域，但是不应该在那里加载任何内容（在某些情况下，该内存必须被清零）。既不可加载也不可分配的 section 通常包含某种调试信息。

每个可加载或可分配的输出 section 都有两个地址。第一个地址是 *VMA* 或虚拟内存地址，这是输出文件运行时的地址。第二个是 LMA 或装载存储器地址（load memory address），这是加载该 section 时的地址。在大多数情况下，两个地址将是相同的。它们可能不同的一个例子是当数据 section 被加载到 ROM 中，然后在程序运行时复制到 RAM 中（这种技术通常用于在基于 ROM 的系统中初始化全局变量）。在这种情况下，ROM 地址将是 LMA，RAM 地址将是 VMA。

您可以使用 `objdump` 程序加 `-h` 选项查看目标文件中的 sections。

每个目标文件还有一个*符号表*（symbol table）。符号可以定义或未定义。每个符号都有一个名称，每个定义的符号都有一个地址，以及其他信息。如果将 C 或 C++ 程序编译为目标文件，则将为每个已定义的函数和全局或静态变量分配 *已定义的符号*。输入文件中引用的每个未定义函数或全局变量都将成为 *未定义的符号*。

您可以使用 nm 程序查看目标文件中的符号（symbols），或使用 objdump 程序加 `-t` 选项。

## 3.2 链接脚本格式

链接脚本是文本文件。

你将使用一系列命令编写链接脚本。每个命令都是关键字，可能命令后跟参数，或者是符号的赋值。您可以使用*分号*分隔命令。空格通常被忽略。

通常可以直接输入文件或格式名称等字符串。如果文件名包含*逗号*等字符，您可以将文件名放在双引号中，否则逗号将用于分隔文件名。无法在文件名中使用双引号字符。

您可以在链接脚本中包含注释，就像在 C 中一样，由 “/*” 和 “*/” 分隔。与在 C 中一样，注释在语法上等同于空格。

## 3.3 简单的链接脚本示例

许多链接脚本都相当简单。

最简单的链接脚本只有一个命令：`SECTIONS`。使用 `SECTIONS` 命令描述输出文件的内存布局。

`SECTIONS` 是一个强大的命令。在这里，我们将描述它的简单用法。假设您的程序仅包含代码，初始化数据和未初始化数据，这三部分将分别存在于 `.text`, `.data` 和 `.bss` 段（section）。我们进一步假设这些是输入文件中出现的唯一部分。

对于这个例子，假设代码加载到 0x10000 地址，并且数据从地址 0x8000000 开始。那么链接脚本如下所示：

```
SECTIONS
{
    . = 0x10000;
    .text : { *(.text) }
    . = 0x8000000;
    .data : { *(.data) }
    .bss : { *(.bss) }
}
```

在链接脚本中将 `SECTIONS` 命令写为关键字 `SECTIONS`，后跟一系列用大括号括起来的符号赋值和输出段（output section）描述。

上面例子，在 `SECTIONS` 命令中的第一行设置特殊符号 `.` 的值，`.` 是位置计数器。如果未以其他方式指定输出段的地址（后面将介绍其他方式），则会根据位置计数器的当前值设置地址。然后，位置计数器增加输出段的大小。在 `SECTIONS` 命令的起始位置处，位置计数器值为 0。

第二行定义了 `.text` 输出段。冒号是必需的语法，现在可以忽略。在输出段名称后的花括号内，列出应放入此输出段的输入段的名称。`*` 是一个匹配任何文件名的通配符。表达方式 `*(.text)` 意味着所有输入文件中的 `.text` 段。

当 `.text` 段定义的时候，位置计数器值为 0x10000，那么链接器将设置 `.text` 段的地址为 0x10000。

其余的行在输出文件中定义了 `.data` 和 `.bss` 段。链接器将 `.data` 输出段放置到 0x8000000 地址。链接器放置 `.data` 段后，位置计数器的值将是 0x8000000 加上 `.data` 段的大小。效果是，在内存中链接器将 `.bss` 段放置到 `.data` 段后面。

链接器将在必要时通过增加位置计数器值来确保每个输出段具有所需的对齐。在此示例中，为 `.text` 和 `.data` 指定的地址可能会满足任何对齐约束，但链接器可能必须在 `.data` 和 `.bss` 段之间创建一个小的间隙，以满足对齐约束。

以上就是全部！这是一个简单且完整的链接脚本。

## 3.4 简单的链接脚本命令



## 3.5 Assignments 将值分配给符号
## 3.6 SECTIONS 命令
## 3.7 MEMORY 命令
## 3.8 PHDRS 命令
## 3.9 VERSION 命令
## 3.10 链接脚本中的表达式
## 3.11 隐式链接描述文件

