
# The GNU Linker

> 本文档由 [MurphyZhao](https://github.com/murphyzhao/) 与 2019 年 8 月 23 日翻译。  
> 文档来源于 **gcc-arm-none-eabi-4_8-2014q3-20140805-linux.tar.bz2** 中的 `share/doc/gcc-arm-none-eabi/html/ld.html`。

```
            ld
(GNU Binutils)
Version 2.23.2
```

此文件基于 GNU 链接器 ld（GNU Binutils）版本 2.23.2。

本文档根据 GNU 自由文档许可证 1.3 版的条款分发。许可证的副本包含在标题为 “GNU 自由文档许可证” 的部分中。

# 1 概览

ld 软件组合一系列的 object 和 archive（目标/归档） 文件，重定位他们的数据并绑定符号引用（symbol references）。通常在程序编译的最后一步执行 ld 软件进行程序链接。

ld 软件接受以 AT＆T 的 **链接编辑器命令语言** 语法的超集编写的链接器命令语言文件，以提供对链接过程的显式和完全控制。

这个版本，LD 使用通用 BFD 库来操作目标文件。这允许 LD 以多种不同的格式读取、组合和写入目标文件 -  例如，COFF 或 a.out。可以将不同的格式链接在一起以产生任何可用类型的目标文件（object file）。有关更多信息，请参阅 BFD。

除了灵活性之外，gnu 链接器在提供诊断信息方面比其他链接器更有帮助。许多链接器在遇到错误时立即放弃执行; 只要有可能，LD  继续执行，允许您识别其他错误（或者，在某些情况下，尽管出现错误，仍然可以获取输出文件）。

# 2 调用 / 祈祷（Invocation）

GNU 链接器 ld 旨在涵盖广泛的情况，并尽可能与其他链接器兼容。因此，您有很多选择来控制其行为。

- Optios：命令行选项
- Environment：环境变量

## 2.1 命令行选项

链接器支持大量的命令行选项，但在实际操作中，只有他们中很少的一部分被用于特定的上下文。 例如，LD 经常被用于在标准的、受支持的 Unix 系统上链接标准的 Unix 目标文件。在这样的系统上，去链接文件 hello.o 如下所示：

```
    ld -o output /lib/crt0.o hello.o -lc
```

上述代码表示 LD 使用 `/lib/crt0.o` 和 `hello.o` 以及 `libc.a` 生成一个名为 *output* 的输出文件，这些输入文件来自标准搜索目录。（参考下面关于 `-l` 选项的讨论）



# 3 链接脚本

每一次链接（link）都是由链接*脚本脚本*。此脚本使用链接器命令语言编写。

链接脚本的主要目的是描述输入文件中的各部分（sections）应如何映射到输出文件，以及控制输出文件的内存布局。大多数链接器脚本仅会执行这些操作。但是，必要时，链接脚本还可以使用下面描述的命令指示链接器执行更多其他操作。

链接器始终使用链接脚本。如果您自己不提供，则链接器将使用编译到链接器可执行文件中的默认脚本。你可以使用 `--verbose` 命令行选项显示默认链接脚本。某些命令行选项，例如 `-r` 要么 `-N`，会影响默认的链接描述文件。

您可以使用 `-T` 命令行选项指定自己的链接描述文件。执行此操作时，链接描述文件将替换默认链接描述文件。

您也可以隐式使用链接描述文件，将它们命名为链接器的输入文件，就好像它们是要链接的文件一样。请参阅[隐式链接描述文件]()。

- Basic Script Concepts: 基本的链接器脚本概念
- Script Format: 链接器脚本格式
- Simple Example: 简单的链接脚本示例
- Simple Commands: 简单的链接脚本命令
- Assignments: 分配，将值分配给符号
- SECTIONS: SECTIONS 命令
- MEMORY: MEMORY 命令
- PHDRS: PHDRS 命令
- VERSION: VERSION 命令
- Expressions: 链接脚本中的表达式
- Implicit Linker Scripts: 隐式链接描述文件

## 3.1 基本的链接器脚本概念

我们需要定义一些基本概念和词汇表来描述链接器脚本语言。

链接器将输入文件合并为单个输出文件。输出文件和每个输入文件采用称为 *目标文件格式* 的特殊数据 格式。每个文件都称为 *目标文件*（object file）。输出文件通常称为 *可执行文件*，但出于我们的目的，我们也将其称为目标文件。除了别的以外，每个目标文件都有一个 `*sections*` 列表。我们有时将输入文件中的一个 section 称为 *输入 section*；类似地，输出文件中的 section 是 *输出 section*。

目标文件中的每个 section 都有名称和大小。大多数 section 还有一个相关的数据块，称为 *section 内容*。一个 section 可能被标记为 *可加载*，这意味着在运行输出文件时，应将 section 内容加载到内存中。没有内容的 section 可以是 *可分配的*，这意味着应该在内存中留出一片区域，但是不应该在那里加载任何内容（在某些情况下，该内存必须被清零）。既不可加载也不可分配的 section 通常包含某种调试信息。

每个可加载或可分配的输出 section 都有两个地址。第一个地址是 *VMA* 或虚拟内存地址，这是输出文件运行时的地址。第二个是 LMA 或装载存储器地址（load memory address），这是加载该 section 时的地址。在大多数情况下，两个地址将是相同的。它们可能不同的一个例子是当数据 section 被加载到 ROM 中，然后在程序运行时复制到 RAM 中（这种技术通常用于在基于 ROM 的系统中初始化全局变量）。在这种情况下，ROM 地址将是 LMA，RAM 地址将是 VMA。

您可以使用 `objdump` 程序加 `-h` 选项查看目标文件中的 sections。

每个目标文件还有一个*符号表*（symbol table）。符号可以定义或未定义。每个符号都有一个名称，每个定义的符号都有一个地址，以及其他信息。如果将 C 或 C++ 程序编译为目标文件，则将为每个已定义的函数和全局或静态变量分配 *已定义的符号*。输入文件中引用的每个未定义函数或全局变量都将成为 *未定义的符号*。

您可以使用 nm 程序查看目标文件中的符号（symbols），或使用 objdump 程序加 `-t` 选项。

## 3.2 链接器脚本格式
## 3.3 简单的链接脚本示例
## 3.4 简单的链接脚本命令
## 3.5 Assignments 将值分配给符号
## 3.6 SECTIONS 命令
## 3.7 MEMORY 命令
## 3.8 PHDRS 命令
## 3.9 VERSION 命令
## 3.10 链接脚本中的表达式
## 3.11 隐式链接描述文件

